// Copyright 2012, Google Inc. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package sqlparser

// SQLNode defines the interface for all nodes
// generated by the parser.
type SQLNode interface {
	Format(buf *TrackedBuffer)
}

// String returns a string representation of an SQLNode.
func String(node SQLNode) string {
	buf := NewTrackedBuffer(nil)
	buf.Fprintf("%v", node)
	return buf.String()
}

// Statement is the interface that needs to be
// satisfied by SQL statement nodes. statement()
// is a dummy function used for verifying that a
// node is a Statement.
type Statement interface {
	statement()
	SQLNode
}

// SelectStatement is the interface that needs to be
// satisfied by all select statements, including
// unions. They need to implement the dummy
// selectStatement function.
type SelectStatement interface {
	selectStatement()
	statement()
	SQLNode
}

// Select represents a SELECT statement.
type Select struct {
	Comments    Comments
	Distinct    Distinct
	SelectExprs SelectExprs
	From        *Node
	Where       *Node
	GroupBy     *Node
	Having      *Node
	OrderBy     *Node
	Limit       *Node
	Lock        *Node
}

func (*Select) statement() {}

func (*Select) selectStatement() {}

func (node *Select) Format(buf *TrackedBuffer) {
	buf.Fprintf("select %v%v%v from %v%v%v%v%v%v%v",
		node.Comments, node.Distinct, node.SelectExprs,
		node.From, node.Where,
		node.GroupBy, node.Having, node.OrderBy,
		node.Limit, node.Lock)
}

// Union represents a UNION statement.
type Union struct {
	Type             []byte
	Select1, Select2 SelectStatement
}

func (*Union) statement() {}

func (*Union) selectStatement() {}

func (node *Union) Format(buf *TrackedBuffer) {
	buf.Fprintf("%v %s %v", node.Select1, node.Type, node.Select2)
}

func selectNode(statement SelectStatement) *Node {
	switch node := statement.(type) {
	case *Select:
		n := NewSimpleParseNode(SELECT, "select")
		n.Push(node.Comments.Node())
		n.Push(node.Distinct.Node())
		n.Push(node.SelectExprs.Node())
		n.Push(node.From)
		n.Push(node.Where)
		n.Push(node.GroupBy)
		n.Push(node.Having)
		n.Push(node.OrderBy)
		n.Push(node.Limit)
		n.Push(node.Lock)
		return n
	case *Union:
		n := NewParseNode(UNION, node.Type)
		n.PushTwo(selectNode(node.Select1), selectNode(node.Select2))
		return n
	}
	panic("unreachable")
}

func newSelect(nd *Node) SelectStatement {
	switch nd.Type {
	case SELECT:
		return &Select{
			Comments:    newComments(nd.At(0)),
			Distinct:    newDistinct(nd.At(1)),
			SelectExprs: newSelectExprsNode(nd.At(2)),
			From:        nd.At(3),
			Where:       nd.At(4),
			GroupBy:     nd.At(5),
			Having:      nd.At(6),
			OrderBy:     nd.At(7),
			Limit:       nd.At(8),
			Lock:        nd.At(9),
		}
	case UNION:
		return &Union{
			Type:    nd.Value,
			Select1: newSelect(nd.At(0)),
			Select2: newSelect(nd.At(1)),
		}
	}
	panic("unreachable")
}

// Insert represents an INSERT statement.
type Insert struct {
	Comments Comments
	Table    *Node
	Columns  *Node
	Values   *Node
	OnDup    *Node
}

func (*Insert) statement() {}

func (node *Insert) Format(buf *TrackedBuffer) {
	buf.Fprintf("insert %vinto %v%v %v%v",
		node.Comments,
		node.Table, node.Columns, node.Values, node.OnDup)
}

// Update represents an UPDATE statement.
type Update struct {
	Comments Comments
	Table    *Node
	List     *Node
	Where    *Node
	OrderBy  *Node
	Limit    *Node
}

func (*Update) statement() {}

func (node *Update) Format(buf *TrackedBuffer) {
	buf.Fprintf("update %v%v set %v%v%v%v",
		node.Comments, node.Table,
		node.List, node.Where, node.OrderBy, node.Limit)
}

// Delete represents a DELETE statement.
type Delete struct {
	Comments Comments
	Table    *Node
	Where    *Node
	OrderBy  *Node
	Limit    *Node
}

func (*Delete) statement() {}

func (node *Delete) Format(buf *TrackedBuffer) {
	buf.Fprintf("delete %vfrom %v%v%v%v",
		node.Comments,
		node.Table, node.Where, node.OrderBy, node.Limit)
}

// Set represents a SET statement.
type Set struct {
	Comments Comments
	Updates  *Node
}

func (*Set) statement() {}

func (node *Set) Format(buf *TrackedBuffer) {
	buf.Fprintf("set %v%v", node.Comments, node.Updates)
}

// DDLSimple represents a CREATE, ALTER or DROP statement.
type DDLSimple struct {
	Action int
	Table  *Node
}

func (*DDLSimple) statement() {}

func (node *DDLSimple) Format(buf *TrackedBuffer) {
	switch node.Action {
	case CREATE:
		buf.Fprintf("create table %v", node.Table)
	case ALTER:
		buf.Fprintf("alter table %v", node.Table)
	case DROP:
		buf.Fprintf("drop table %v", node.Table)
	default:
		panic("unreachable")
	}
}

// Rename represents a RENAME statement.
type Rename struct {
	OldName, NewName *Node
}

func (*Rename) statement() {}

func (node *Rename) Format(buf *TrackedBuffer) {
	buf.Fprintf("rename table %v %v", node.OldName, node.NewName)
}

// Comments represents a list of comments.
type Comments []Comment

func (node Comments) Format(buf *TrackedBuffer) {
	for _, c := range node {
		c.Format(buf)
	}
}

func (node Comments) Node() *Node {
	nd := NewSimpleParseNode(COMMENT_LIST, "")
	for _, c := range node {
		nd.Push(NewParseNode(COMMENT, []byte(c)))
	}
	return nd
}

func newComments(nd *Node) Comments {
	if nd.Type != COMMENT_LIST {
		panic("unreachable: not a comment list")
	}
	var node Comments
	for i := 0; i < nd.Len(); i++ {
		node = append(node, Comment(nd.At(i).Value))
	}
	return node
}

// Comment represents one comment.
type Comment []byte

func (comment Comment) Format(buf *TrackedBuffer) {
	buf.Fprintf("%s ", []byte(comment))
}

// Distinct specifies if DISTINCT was used.
type Distinct bool

func (node Distinct) Format(buf *TrackedBuffer) {
	if node {
		buf.Fprintf("distinct ")
	}
}

func (node Distinct) Node() *Node {
	if node {
		return NewSimpleParseNode(DISTINCT, "distinct")
	}
	return NewSimpleParseNode(NO_DISTINCT, "")
}

func newDistinct(nd *Node) Distinct {
	switch nd.Type {
	case DISTINCT:
		return Distinct(true)
	case NO_DISTINCT:
		return Distinct(false)
	}
	panic("not a distinct nd")
}

// SelectExprs represents SELECT expressions.
type SelectExprs []*Node

func (node SelectExprs) Format(buf *TrackedBuffer) {
	for i, sel := range node {
		if i == 0 {
			buf.Fprintf("%v", sel)
		} else {
			buf.Fprintf(", %v", sel)
		}
	}
}

func (node SelectExprs) Node() *Node {
	nd := NewSimpleParseNode(NODE_LIST, "")
	for _, sel := range node {
		nd.Push(sel)
	}
	return nd
}

func newSelectExprsNode(nd *Node) SelectExprs {
	var node SelectExprs
	for i := 0; i < nd.Len(); i++ {
		node = append(node, nd.At(i))
	}
	return node
}
