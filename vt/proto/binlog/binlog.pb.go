// Code generated by protoc-gen-go.
// source: binlog.proto
// DO NOT EDIT!

/*
Package binlog is a generated protocol buffer package.

It is generated from these files:
	binlog.proto

It has these top-level messages:
	Charset
	BinlogTransaction
	StreamUpdateRequest
	StreamUpdateResponse
	StreamKeyRangeRequest
	StreamKeyRangeResponse
	StreamTablesRequest
	StreamTablesResponse
*/
package binlog

import proto "github.com/golang/protobuf/proto"
import topo "github.com/youtube/vitess/go/vt/proto/topo"
import replication "github.com/youtube/vitess/go/vt/proto/replication"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal

type BinlogTransaction_Statement_Category int32

const (
	BinlogTransaction_Statement_BL_UNRECOGNIZED BinlogTransaction_Statement_Category = 0
	BinlogTransaction_Statement_BL_BEGIN        BinlogTransaction_Statement_Category = 1
	BinlogTransaction_Statement_BL_COMMIT       BinlogTransaction_Statement_Category = 2
	BinlogTransaction_Statement_BL_ROLLBACK     BinlogTransaction_Statement_Category = 3
	BinlogTransaction_Statement_BL_DML          BinlogTransaction_Statement_Category = 4
	BinlogTransaction_Statement_BL_DDL          BinlogTransaction_Statement_Category = 5
	BinlogTransaction_Statement_BL_SET          BinlogTransaction_Statement_Category = 6
)

var BinlogTransaction_Statement_Category_name = map[int32]string{
	0: "BL_UNRECOGNIZED",
	1: "BL_BEGIN",
	2: "BL_COMMIT",
	3: "BL_ROLLBACK",
	4: "BL_DML",
	5: "BL_DDL",
	6: "BL_SET",
}
var BinlogTransaction_Statement_Category_value = map[string]int32{
	"BL_UNRECOGNIZED": 0,
	"BL_BEGIN":        1,
	"BL_COMMIT":       2,
	"BL_ROLLBACK":     3,
	"BL_DML":          4,
	"BL_DDL":          5,
	"BL_SET":          6,
}

func (x BinlogTransaction_Statement_Category) String() string {
	return proto.EnumName(BinlogTransaction_Statement_Category_name, int32(x))
}

// Charset is the per-statement charset info from a QUERY_EVENT binlog entry.
type Charset struct {
	// @@session.character_set_client
	Client int32 `protobuf:"varint,1,opt,name=client" json:"client,omitempty"`
	// @@session.collation_connection
	Conn int32 `protobuf:"varint,2,opt,name=conn" json:"conn,omitempty"`
	// @@session.collation_server
	Server int32 `protobuf:"varint,3,opt,name=server" json:"server,omitempty"`
}

func (m *Charset) Reset()         { *m = Charset{} }
func (m *Charset) String() string { return proto.CompactTextString(m) }
func (*Charset) ProtoMessage()    {}

// BinlogTransaction describes a transaction inside the binlogs.
type BinlogTransaction struct {
	// the statements in this transaction
	Statements []*BinlogTransaction_Statement `protobuf:"bytes,1,rep,name=statements" json:"statements,omitempty"`
	// the timestamp of the statements
	Timestamp int64 `protobuf:"varint,2,opt,name=timestamp" json:"timestamp,omitempty"`
	// the Global Transaction ID after the statements have been applied
	Gtid string `protobuf:"bytes,3,opt,name=gtid" json:"gtid,omitempty"`
}

func (m *BinlogTransaction) Reset()         { *m = BinlogTransaction{} }
func (m *BinlogTransaction) String() string { return proto.CompactTextString(m) }
func (*BinlogTransaction) ProtoMessage()    {}

func (m *BinlogTransaction) GetStatements() []*BinlogTransaction_Statement {
	if m != nil {
		return m.Statements
	}
	return nil
}

type BinlogTransaction_Statement struct {
	// what type of statement is this?
	Category BinlogTransaction_Statement_Category `protobuf:"varint,1,opt,name=category,enum=binlog.BinlogTransaction_Statement_Category" json:"category,omitempty"`
	// charset of this statement, if different from pre-negotiated default.
	Charset *Charset `protobuf:"bytes,3,opt,name=charset" json:"charset,omitempty"`
	// the sql
	Sql []byte `protobuf:"bytes,2,opt,name=sql,proto3" json:"sql,omitempty"`
}

func (m *BinlogTransaction_Statement) Reset()         { *m = BinlogTransaction_Statement{} }
func (m *BinlogTransaction_Statement) String() string { return proto.CompactTextString(m) }
func (*BinlogTransaction_Statement) ProtoMessage()    {}

func (m *BinlogTransaction_Statement) GetCharset() *Charset {
	if m != nil {
		return m.Charset
	}
	return nil
}

// StreamUpdateRequest is the payload to StreamUpdate
type StreamUpdateRequest struct {
	// where to start
	Position *replication.Position `protobuf:"bytes,1,opt,name=position" json:"position,omitempty"`
}

func (m *StreamUpdateRequest) Reset()         { *m = StreamUpdateRequest{} }
func (m *StreamUpdateRequest) String() string { return proto.CompactTextString(m) }
func (*StreamUpdateRequest) ProtoMessage()    {}

func (m *StreamUpdateRequest) GetPosition() *replication.Position {
	if m != nil {
		return m.Position
	}
	return nil
}

// StreamUpdateResponse is the response from StreamUpdate
type StreamUpdateResponse struct {
}

func (m *StreamUpdateResponse) Reset()         { *m = StreamUpdateResponse{} }
func (m *StreamUpdateResponse) String() string { return proto.CompactTextString(m) }
func (*StreamUpdateResponse) ProtoMessage()    {}

// StreamKeyRangeRequest is the payload to StreamKeyRange
type StreamKeyRangeRequest struct {
	// where to start
	Position *replication.Position `protobuf:"bytes,1,opt,name=position" json:"position,omitempty"`
	// type to get
	KeyspaceIdType topo.KeyspaceIdType `protobuf:"varint,2,opt,name=keyspace_id_type,enum=topo.KeyspaceIdType" json:"keyspace_id_type,omitempty"`
	// what to get
	KeyRange *topo.KeyRange `protobuf:"bytes,3,opt,name=key_range" json:"key_range,omitempty"`
	// default charset on the player side
	Charset *Charset `protobuf:"bytes,4,opt,name=charset" json:"charset,omitempty"`
}

func (m *StreamKeyRangeRequest) Reset()         { *m = StreamKeyRangeRequest{} }
func (m *StreamKeyRangeRequest) String() string { return proto.CompactTextString(m) }
func (*StreamKeyRangeRequest) ProtoMessage()    {}

func (m *StreamKeyRangeRequest) GetPosition() *replication.Position {
	if m != nil {
		return m.Position
	}
	return nil
}

func (m *StreamKeyRangeRequest) GetKeyRange() *topo.KeyRange {
	if m != nil {
		return m.KeyRange
	}
	return nil
}

func (m *StreamKeyRangeRequest) GetCharset() *Charset {
	if m != nil {
		return m.Charset
	}
	return nil
}

// StreamKeyRangeResponse is the response from StreamKeyRange
type StreamKeyRangeResponse struct {
	BinlogTransaction *BinlogTransaction `protobuf:"bytes,1,opt,name=binlog_transaction" json:"binlog_transaction,omitempty"`
}

func (m *StreamKeyRangeResponse) Reset()         { *m = StreamKeyRangeResponse{} }
func (m *StreamKeyRangeResponse) String() string { return proto.CompactTextString(m) }
func (*StreamKeyRangeResponse) ProtoMessage()    {}

func (m *StreamKeyRangeResponse) GetBinlogTransaction() *BinlogTransaction {
	if m != nil {
		return m.BinlogTransaction
	}
	return nil
}

// StreamTablesRequest is the payload to StreamTables
type StreamTablesRequest struct {
	// where to start
	Position *replication.Position `protobuf:"bytes,1,opt,name=position" json:"position,omitempty"`
	// what to get
	Tables []string `protobuf:"bytes,2,rep,name=tables" json:"tables,omitempty"`
	// default charset on the player side
	Charset *Charset `protobuf:"bytes,3,opt,name=charset" json:"charset,omitempty"`
}

func (m *StreamTablesRequest) Reset()         { *m = StreamTablesRequest{} }
func (m *StreamTablesRequest) String() string { return proto.CompactTextString(m) }
func (*StreamTablesRequest) ProtoMessage()    {}

func (m *StreamTablesRequest) GetPosition() *replication.Position {
	if m != nil {
		return m.Position
	}
	return nil
}

func (m *StreamTablesRequest) GetCharset() *Charset {
	if m != nil {
		return m.Charset
	}
	return nil
}

// StreamTablesResponse is the response from StreamTables
type StreamTablesResponse struct {
	BinlogTransaction *BinlogTransaction `protobuf:"bytes,1,opt,name=binlog_transaction" json:"binlog_transaction,omitempty"`
}

func (m *StreamTablesResponse) Reset()         { *m = StreamTablesResponse{} }
func (m *StreamTablesResponse) String() string { return proto.CompactTextString(m) }
func (*StreamTablesResponse) ProtoMessage()    {}

func (m *StreamTablesResponse) GetBinlogTransaction() *BinlogTransaction {
	if m != nil {
		return m.BinlogTransaction
	}
	return nil
}

func init() {
	proto.RegisterEnum("binlog.BinlogTransaction_Statement_Category", BinlogTransaction_Statement_Category_name, BinlogTransaction_Statement_Category_value)
}

// Client API for UpdateStream service

type UpdateStreamClient interface {
	// StreamUpdate streams the binlog events, to know which objects have changed.
	StreamUpdate(ctx context.Context, in *StreamUpdateRequest, opts ...grpc.CallOption) (*StreamUpdateResponse, error)
	// StreamKeyRange returns the binlog transactions related to
	// the specified Keyrange.
	StreamKeyRange(ctx context.Context, in *StreamKeyRangeRequest, opts ...grpc.CallOption) (*StreamKeyRangeResponse, error)
	// StreamTables returns the binlog transactions related to
	// the specified Tables.
	StreamTables(ctx context.Context, in *StreamTablesRequest, opts ...grpc.CallOption) (*StreamTablesResponse, error)
}

type updateStreamClient struct {
	cc *grpc.ClientConn
}

func NewUpdateStreamClient(cc *grpc.ClientConn) UpdateStreamClient {
	return &updateStreamClient{cc}
}

func (c *updateStreamClient) StreamUpdate(ctx context.Context, in *StreamUpdateRequest, opts ...grpc.CallOption) (*StreamUpdateResponse, error) {
	out := new(StreamUpdateResponse)
	err := grpc.Invoke(ctx, "/binlog.UpdateStream/StreamUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateStreamClient) StreamKeyRange(ctx context.Context, in *StreamKeyRangeRequest, opts ...grpc.CallOption) (*StreamKeyRangeResponse, error) {
	out := new(StreamKeyRangeResponse)
	err := grpc.Invoke(ctx, "/binlog.UpdateStream/StreamKeyRange", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateStreamClient) StreamTables(ctx context.Context, in *StreamTablesRequest, opts ...grpc.CallOption) (*StreamTablesResponse, error) {
	out := new(StreamTablesResponse)
	err := grpc.Invoke(ctx, "/binlog.UpdateStream/StreamTables", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for UpdateStream service

type UpdateStreamServer interface {
	// StreamUpdate streams the binlog events, to know which objects have changed.
	StreamUpdate(context.Context, *StreamUpdateRequest) (*StreamUpdateResponse, error)
	// StreamKeyRange returns the binlog transactions related to
	// the specified Keyrange.
	StreamKeyRange(context.Context, *StreamKeyRangeRequest) (*StreamKeyRangeResponse, error)
	// StreamTables returns the binlog transactions related to
	// the specified Tables.
	StreamTables(context.Context, *StreamTablesRequest) (*StreamTablesResponse, error)
}

func RegisterUpdateStreamServer(s *grpc.Server, srv UpdateStreamServer) {
	s.RegisterService(&_UpdateStream_serviceDesc, srv)
}

func _UpdateStream_StreamUpdate_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(StreamUpdateRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(UpdateStreamServer).StreamUpdate(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _UpdateStream_StreamKeyRange_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(StreamKeyRangeRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(UpdateStreamServer).StreamKeyRange(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _UpdateStream_StreamTables_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(StreamTablesRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(UpdateStreamServer).StreamTables(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _UpdateStream_serviceDesc = grpc.ServiceDesc{
	ServiceName: "binlog.UpdateStream",
	HandlerType: (*UpdateStreamServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StreamUpdate",
			Handler:    _UpdateStream_StreamUpdate_Handler,
		},
		{
			MethodName: "StreamKeyRange",
			Handler:    _UpdateStream_StreamKeyRange_Handler,
		},
		{
			MethodName: "StreamTables",
			Handler:    _UpdateStream_StreamTables_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}
