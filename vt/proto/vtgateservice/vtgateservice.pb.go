// Code generated by protoc-gen-go.
// source: vtgateservice.proto
// DO NOT EDIT!

/*
Package vtgateservice is a generated protocol buffer package.

It is generated from these files:
	vtgateservice.proto

It has these top-level messages:
*/
package vtgateservice

import proto "github.com/golang/protobuf/proto"
import vtgate "github.com/youtube/vitess/go/vt/proto/vtgate"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal

func init() {
}

// Client API for VTGate service

type VTGateClient interface {
	// Execute executes tries to route the query to the right shard.
	// (this is a vtgate v3 API, use carefully)
	Execute(ctx context.Context, in *vtgate.ExecuteRequest, opts ...grpc.CallOption) (*vtgate.ExecuteResponse, error)
	// ExecuteShards executes the query on the specified shards.
	ExecuteShards(ctx context.Context, in *vtgate.ExecuteShardsRequest, opts ...grpc.CallOption) (*vtgate.ExecuteShardsResponse, error)
	// ExecuteKeyspaceIds executes the query based on the specified keyspace ids.
	ExecuteKeyspaceIds(ctx context.Context, in *vtgate.ExecuteKeyspaceIdsRequest, opts ...grpc.CallOption) (*vtgate.ExecuteKeyspaceIdsResponse, error)
	// ExecuteKeyRanges executes the query based on the specified key ranges.
	ExecuteKeyRanges(ctx context.Context, in *vtgate.ExecuteKeyRangesRequest, opts ...grpc.CallOption) (*vtgate.ExecuteKeyRangesResponse, error)
	// ExecuteEntityIds executes the query based on the specified external id to keyspace id map.
	ExecuteEntityIds(ctx context.Context, in *vtgate.ExecuteEntityIdsRequest, opts ...grpc.CallOption) (*vtgate.ExecuteEntityIdsResponse, error)
	// ExecuteBatchShards executes the list of queries on the specified shards.
	ExecuteBatchShards(ctx context.Context, in *vtgate.ExecuteBatchShardsRequest, opts ...grpc.CallOption) (*vtgate.ExecuteBatchShardsResponse, error)
	// ExecuteBatchKeyspaceIds executes the list of queries based on the specified keyspace ids.
	ExecuteBatchKeyspaceIds(ctx context.Context, in *vtgate.ExecuteBatchKeyspaceIdsRequest, opts ...grpc.CallOption) (*vtgate.ExecuteBatchKeyspaceIdsResponse, error)
	// StreamExecute exectures a streaming query based on shards.
	// (this is a vtgate v3 API, use carefully)
	StreamExecute(ctx context.Context, in *vtgate.StreamExecuteRequest, opts ...grpc.CallOption) (VTGate_StreamExecuteClient, error)
	// StreamExecuteShard exectures a streaming query based on shards.
	// Use this method if the query returns a large number of rows.
	StreamExecuteShards(ctx context.Context, in *vtgate.StreamExecuteShardsRequest, opts ...grpc.CallOption) (VTGate_StreamExecuteShardsClient, error)
	// StreamExecuteKeyspaceIds exectures a streaming query based on keyspace ids.
	// Use this method if the query returns a large number of rows.
	StreamExecuteKeyspaceIds(ctx context.Context, in *vtgate.StreamExecuteKeyspaceIdsRequest, opts ...grpc.CallOption) (VTGate_StreamExecuteKeyspaceIdsClient, error)
	// StreamExecuteKeyRanges exectures a streaming query based on key ranges.
	// Use this method if the query returns a large number of rows.
	StreamExecuteKeyRanges(ctx context.Context, in *vtgate.StreamExecuteKeyRangesRequest, opts ...grpc.CallOption) (VTGate_StreamExecuteKeyRangesClient, error)
	// Begin a transaction.
	Begin(ctx context.Context, in *vtgate.BeginRequest, opts ...grpc.CallOption) (*vtgate.BeginResponse, error)
	// Commit a transaction.
	Commit(ctx context.Context, in *vtgate.CommitRequest, opts ...grpc.CallOption) (*vtgate.CommitResponse, error)
	// Rollback a transaction.
	Rollback(ctx context.Context, in *vtgate.RollbackRequest, opts ...grpc.CallOption) (*vtgate.RollbackResponse, error)
	// Split a query into non-overlapping sub queries
	SplitQuery(ctx context.Context, in *vtgate.SplitQueryRequest, opts ...grpc.CallOption) (*vtgate.SplitQueryResponse, error)
}

type vTGateClient struct {
	cc *grpc.ClientConn
}

func NewVTGateClient(cc *grpc.ClientConn) VTGateClient {
	return &vTGateClient{cc}
}

func (c *vTGateClient) Execute(ctx context.Context, in *vtgate.ExecuteRequest, opts ...grpc.CallOption) (*vtgate.ExecuteResponse, error) {
	out := new(vtgate.ExecuteResponse)
	err := grpc.Invoke(ctx, "/vtgateservice.VTGate/Execute", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vTGateClient) ExecuteShards(ctx context.Context, in *vtgate.ExecuteShardsRequest, opts ...grpc.CallOption) (*vtgate.ExecuteShardsResponse, error) {
	out := new(vtgate.ExecuteShardsResponse)
	err := grpc.Invoke(ctx, "/vtgateservice.VTGate/ExecuteShards", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vTGateClient) ExecuteKeyspaceIds(ctx context.Context, in *vtgate.ExecuteKeyspaceIdsRequest, opts ...grpc.CallOption) (*vtgate.ExecuteKeyspaceIdsResponse, error) {
	out := new(vtgate.ExecuteKeyspaceIdsResponse)
	err := grpc.Invoke(ctx, "/vtgateservice.VTGate/ExecuteKeyspaceIds", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vTGateClient) ExecuteKeyRanges(ctx context.Context, in *vtgate.ExecuteKeyRangesRequest, opts ...grpc.CallOption) (*vtgate.ExecuteKeyRangesResponse, error) {
	out := new(vtgate.ExecuteKeyRangesResponse)
	err := grpc.Invoke(ctx, "/vtgateservice.VTGate/ExecuteKeyRanges", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vTGateClient) ExecuteEntityIds(ctx context.Context, in *vtgate.ExecuteEntityIdsRequest, opts ...grpc.CallOption) (*vtgate.ExecuteEntityIdsResponse, error) {
	out := new(vtgate.ExecuteEntityIdsResponse)
	err := grpc.Invoke(ctx, "/vtgateservice.VTGate/ExecuteEntityIds", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vTGateClient) ExecuteBatchShards(ctx context.Context, in *vtgate.ExecuteBatchShardsRequest, opts ...grpc.CallOption) (*vtgate.ExecuteBatchShardsResponse, error) {
	out := new(vtgate.ExecuteBatchShardsResponse)
	err := grpc.Invoke(ctx, "/vtgateservice.VTGate/ExecuteBatchShards", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vTGateClient) ExecuteBatchKeyspaceIds(ctx context.Context, in *vtgate.ExecuteBatchKeyspaceIdsRequest, opts ...grpc.CallOption) (*vtgate.ExecuteBatchKeyspaceIdsResponse, error) {
	out := new(vtgate.ExecuteBatchKeyspaceIdsResponse)
	err := grpc.Invoke(ctx, "/vtgateservice.VTGate/ExecuteBatchKeyspaceIds", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vTGateClient) StreamExecute(ctx context.Context, in *vtgate.StreamExecuteRequest, opts ...grpc.CallOption) (VTGate_StreamExecuteClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_VTGate_serviceDesc.Streams[0], c.cc, "/vtgateservice.VTGate/StreamExecute", opts...)
	if err != nil {
		return nil, err
	}
	x := &vTGateStreamExecuteClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type VTGate_StreamExecuteClient interface {
	Recv() (*vtgate.StreamExecuteResponse, error)
	grpc.ClientStream
}

type vTGateStreamExecuteClient struct {
	grpc.ClientStream
}

func (x *vTGateStreamExecuteClient) Recv() (*vtgate.StreamExecuteResponse, error) {
	m := new(vtgate.StreamExecuteResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vTGateClient) StreamExecuteShards(ctx context.Context, in *vtgate.StreamExecuteShardsRequest, opts ...grpc.CallOption) (VTGate_StreamExecuteShardsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_VTGate_serviceDesc.Streams[1], c.cc, "/vtgateservice.VTGate/StreamExecuteShards", opts...)
	if err != nil {
		return nil, err
	}
	x := &vTGateStreamExecuteShardsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type VTGate_StreamExecuteShardsClient interface {
	Recv() (*vtgate.StreamExecuteShardsResponse, error)
	grpc.ClientStream
}

type vTGateStreamExecuteShardsClient struct {
	grpc.ClientStream
}

func (x *vTGateStreamExecuteShardsClient) Recv() (*vtgate.StreamExecuteShardsResponse, error) {
	m := new(vtgate.StreamExecuteShardsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vTGateClient) StreamExecuteKeyspaceIds(ctx context.Context, in *vtgate.StreamExecuteKeyspaceIdsRequest, opts ...grpc.CallOption) (VTGate_StreamExecuteKeyspaceIdsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_VTGate_serviceDesc.Streams[2], c.cc, "/vtgateservice.VTGate/StreamExecuteKeyspaceIds", opts...)
	if err != nil {
		return nil, err
	}
	x := &vTGateStreamExecuteKeyspaceIdsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type VTGate_StreamExecuteKeyspaceIdsClient interface {
	Recv() (*vtgate.StreamExecuteKeyspaceIdsResponse, error)
	grpc.ClientStream
}

type vTGateStreamExecuteKeyspaceIdsClient struct {
	grpc.ClientStream
}

func (x *vTGateStreamExecuteKeyspaceIdsClient) Recv() (*vtgate.StreamExecuteKeyspaceIdsResponse, error) {
	m := new(vtgate.StreamExecuteKeyspaceIdsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vTGateClient) StreamExecuteKeyRanges(ctx context.Context, in *vtgate.StreamExecuteKeyRangesRequest, opts ...grpc.CallOption) (VTGate_StreamExecuteKeyRangesClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_VTGate_serviceDesc.Streams[3], c.cc, "/vtgateservice.VTGate/StreamExecuteKeyRanges", opts...)
	if err != nil {
		return nil, err
	}
	x := &vTGateStreamExecuteKeyRangesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type VTGate_StreamExecuteKeyRangesClient interface {
	Recv() (*vtgate.StreamExecuteKeyRangesResponse, error)
	grpc.ClientStream
}

type vTGateStreamExecuteKeyRangesClient struct {
	grpc.ClientStream
}

func (x *vTGateStreamExecuteKeyRangesClient) Recv() (*vtgate.StreamExecuteKeyRangesResponse, error) {
	m := new(vtgate.StreamExecuteKeyRangesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *vTGateClient) Begin(ctx context.Context, in *vtgate.BeginRequest, opts ...grpc.CallOption) (*vtgate.BeginResponse, error) {
	out := new(vtgate.BeginResponse)
	err := grpc.Invoke(ctx, "/vtgateservice.VTGate/Begin", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vTGateClient) Commit(ctx context.Context, in *vtgate.CommitRequest, opts ...grpc.CallOption) (*vtgate.CommitResponse, error) {
	out := new(vtgate.CommitResponse)
	err := grpc.Invoke(ctx, "/vtgateservice.VTGate/Commit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vTGateClient) Rollback(ctx context.Context, in *vtgate.RollbackRequest, opts ...grpc.CallOption) (*vtgate.RollbackResponse, error) {
	out := new(vtgate.RollbackResponse)
	err := grpc.Invoke(ctx, "/vtgateservice.VTGate/Rollback", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vTGateClient) SplitQuery(ctx context.Context, in *vtgate.SplitQueryRequest, opts ...grpc.CallOption) (*vtgate.SplitQueryResponse, error) {
	out := new(vtgate.SplitQueryResponse)
	err := grpc.Invoke(ctx, "/vtgateservice.VTGate/SplitQuery", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for VTGate service

type VTGateServer interface {
	// Execute executes tries to route the query to the right shard.
	// (this is a vtgate v3 API, use carefully)
	Execute(context.Context, *vtgate.ExecuteRequest) (*vtgate.ExecuteResponse, error)
	// ExecuteShards executes the query on the specified shards.
	ExecuteShards(context.Context, *vtgate.ExecuteShardsRequest) (*vtgate.ExecuteShardsResponse, error)
	// ExecuteKeyspaceIds executes the query based on the specified keyspace ids.
	ExecuteKeyspaceIds(context.Context, *vtgate.ExecuteKeyspaceIdsRequest) (*vtgate.ExecuteKeyspaceIdsResponse, error)
	// ExecuteKeyRanges executes the query based on the specified key ranges.
	ExecuteKeyRanges(context.Context, *vtgate.ExecuteKeyRangesRequest) (*vtgate.ExecuteKeyRangesResponse, error)
	// ExecuteEntityIds executes the query based on the specified external id to keyspace id map.
	ExecuteEntityIds(context.Context, *vtgate.ExecuteEntityIdsRequest) (*vtgate.ExecuteEntityIdsResponse, error)
	// ExecuteBatchShards executes the list of queries on the specified shards.
	ExecuteBatchShards(context.Context, *vtgate.ExecuteBatchShardsRequest) (*vtgate.ExecuteBatchShardsResponse, error)
	// ExecuteBatchKeyspaceIds executes the list of queries based on the specified keyspace ids.
	ExecuteBatchKeyspaceIds(context.Context, *vtgate.ExecuteBatchKeyspaceIdsRequest) (*vtgate.ExecuteBatchKeyspaceIdsResponse, error)
	// StreamExecute exectures a streaming query based on shards.
	// (this is a vtgate v3 API, use carefully)
	StreamExecute(*vtgate.StreamExecuteRequest, VTGate_StreamExecuteServer) error
	// StreamExecuteShard exectures a streaming query based on shards.
	// Use this method if the query returns a large number of rows.
	StreamExecuteShards(*vtgate.StreamExecuteShardsRequest, VTGate_StreamExecuteShardsServer) error
	// StreamExecuteKeyspaceIds exectures a streaming query based on keyspace ids.
	// Use this method if the query returns a large number of rows.
	StreamExecuteKeyspaceIds(*vtgate.StreamExecuteKeyspaceIdsRequest, VTGate_StreamExecuteKeyspaceIdsServer) error
	// StreamExecuteKeyRanges exectures a streaming query based on key ranges.
	// Use this method if the query returns a large number of rows.
	StreamExecuteKeyRanges(*vtgate.StreamExecuteKeyRangesRequest, VTGate_StreamExecuteKeyRangesServer) error
	// Begin a transaction.
	Begin(context.Context, *vtgate.BeginRequest) (*vtgate.BeginResponse, error)
	// Commit a transaction.
	Commit(context.Context, *vtgate.CommitRequest) (*vtgate.CommitResponse, error)
	// Rollback a transaction.
	Rollback(context.Context, *vtgate.RollbackRequest) (*vtgate.RollbackResponse, error)
	// Split a query into non-overlapping sub queries
	SplitQuery(context.Context, *vtgate.SplitQueryRequest) (*vtgate.SplitQueryResponse, error)
}

func RegisterVTGateServer(s *grpc.Server, srv VTGateServer) {
	s.RegisterService(&_VTGate_serviceDesc, srv)
}

func _VTGate_Execute_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(vtgate.ExecuteRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(VTGateServer).Execute(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _VTGate_ExecuteShards_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(vtgate.ExecuteShardsRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(VTGateServer).ExecuteShards(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _VTGate_ExecuteKeyspaceIds_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(vtgate.ExecuteKeyspaceIdsRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(VTGateServer).ExecuteKeyspaceIds(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _VTGate_ExecuteKeyRanges_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(vtgate.ExecuteKeyRangesRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(VTGateServer).ExecuteKeyRanges(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _VTGate_ExecuteEntityIds_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(vtgate.ExecuteEntityIdsRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(VTGateServer).ExecuteEntityIds(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _VTGate_ExecuteBatchShards_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(vtgate.ExecuteBatchShardsRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(VTGateServer).ExecuteBatchShards(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _VTGate_ExecuteBatchKeyspaceIds_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(vtgate.ExecuteBatchKeyspaceIdsRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(VTGateServer).ExecuteBatchKeyspaceIds(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _VTGate_StreamExecute_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(vtgate.StreamExecuteRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VTGateServer).StreamExecute(m, &vTGateStreamExecuteServer{stream})
}

type VTGate_StreamExecuteServer interface {
	Send(*vtgate.StreamExecuteResponse) error
	grpc.ServerStream
}

type vTGateStreamExecuteServer struct {
	grpc.ServerStream
}

func (x *vTGateStreamExecuteServer) Send(m *vtgate.StreamExecuteResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _VTGate_StreamExecuteShards_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(vtgate.StreamExecuteShardsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VTGateServer).StreamExecuteShards(m, &vTGateStreamExecuteShardsServer{stream})
}

type VTGate_StreamExecuteShardsServer interface {
	Send(*vtgate.StreamExecuteShardsResponse) error
	grpc.ServerStream
}

type vTGateStreamExecuteShardsServer struct {
	grpc.ServerStream
}

func (x *vTGateStreamExecuteShardsServer) Send(m *vtgate.StreamExecuteShardsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _VTGate_StreamExecuteKeyspaceIds_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(vtgate.StreamExecuteKeyspaceIdsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VTGateServer).StreamExecuteKeyspaceIds(m, &vTGateStreamExecuteKeyspaceIdsServer{stream})
}

type VTGate_StreamExecuteKeyspaceIdsServer interface {
	Send(*vtgate.StreamExecuteKeyspaceIdsResponse) error
	grpc.ServerStream
}

type vTGateStreamExecuteKeyspaceIdsServer struct {
	grpc.ServerStream
}

func (x *vTGateStreamExecuteKeyspaceIdsServer) Send(m *vtgate.StreamExecuteKeyspaceIdsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _VTGate_StreamExecuteKeyRanges_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(vtgate.StreamExecuteKeyRangesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VTGateServer).StreamExecuteKeyRanges(m, &vTGateStreamExecuteKeyRangesServer{stream})
}

type VTGate_StreamExecuteKeyRangesServer interface {
	Send(*vtgate.StreamExecuteKeyRangesResponse) error
	grpc.ServerStream
}

type vTGateStreamExecuteKeyRangesServer struct {
	grpc.ServerStream
}

func (x *vTGateStreamExecuteKeyRangesServer) Send(m *vtgate.StreamExecuteKeyRangesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _VTGate_Begin_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(vtgate.BeginRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(VTGateServer).Begin(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _VTGate_Commit_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(vtgate.CommitRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(VTGateServer).Commit(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _VTGate_Rollback_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(vtgate.RollbackRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(VTGateServer).Rollback(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _VTGate_SplitQuery_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(vtgate.SplitQueryRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(VTGateServer).SplitQuery(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _VTGate_serviceDesc = grpc.ServiceDesc{
	ServiceName: "vtgateservice.VTGate",
	HandlerType: (*VTGateServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Execute",
			Handler:    _VTGate_Execute_Handler,
		},
		{
			MethodName: "ExecuteShards",
			Handler:    _VTGate_ExecuteShards_Handler,
		},
		{
			MethodName: "ExecuteKeyspaceIds",
			Handler:    _VTGate_ExecuteKeyspaceIds_Handler,
		},
		{
			MethodName: "ExecuteKeyRanges",
			Handler:    _VTGate_ExecuteKeyRanges_Handler,
		},
		{
			MethodName: "ExecuteEntityIds",
			Handler:    _VTGate_ExecuteEntityIds_Handler,
		},
		{
			MethodName: "ExecuteBatchShards",
			Handler:    _VTGate_ExecuteBatchShards_Handler,
		},
		{
			MethodName: "ExecuteBatchKeyspaceIds",
			Handler:    _VTGate_ExecuteBatchKeyspaceIds_Handler,
		},
		{
			MethodName: "Begin",
			Handler:    _VTGate_Begin_Handler,
		},
		{
			MethodName: "Commit",
			Handler:    _VTGate_Commit_Handler,
		},
		{
			MethodName: "Rollback",
			Handler:    _VTGate_Rollback_Handler,
		},
		{
			MethodName: "SplitQuery",
			Handler:    _VTGate_SplitQuery_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamExecute",
			Handler:       _VTGate_StreamExecute_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamExecuteShards",
			Handler:       _VTGate_StreamExecuteShards_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamExecuteKeyspaceIds",
			Handler:       _VTGate_StreamExecuteKeyspaceIds_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamExecuteKeyRanges",
			Handler:       _VTGate_StreamExecuteKeyRanges_Handler,
			ServerStreams: true,
		},
	},
}
